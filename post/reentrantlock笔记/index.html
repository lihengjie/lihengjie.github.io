<!doctype html>
<html>
<head>
    <base href="http://hugo.spf13.com/">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta name="author" content="John Doe">

<meta name="description" content="">

<title>ReentrantLock笔记</title>
<meta name="generator" content="Hugo 0.40.1" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.1.0/styles/pojoaque.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.1.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400,700" rel="stylesheet" type="text/css">
<link  href="http://hugo.spf13.com//css/theme.min.css" rel="stylesheet" type="text/css">

</head>
<body>
<div class="page-container container-fluid">
<div class="col-md-3 menu">
    <nav class="col-md-3">
    
    <h3 class="home-link"><a href="http://hugo.spf13.com/">Root</a></h3>
    <div id="last-posts" class="open">
        <h3 data-open="last-posts">Hugo Themes - Most recent posts</h3>
        <ul>
            
            <li><a href="http://hugo.spf13.com/post/volatile%E7%AC%94%E8%AE%B0/">Volatile笔记</a></li>
            
            <li><a href="http://hugo.spf13.com/post/tcpdump%E7%AC%94%E8%AE%B0/">Tcpdump笔记</a></li>
            
            <li><a href="http://hugo.spf13.com/post/semaphore%E7%AC%94%E8%AE%B0/">Semaphore笔记</a></li>
            
            <li><a href="http://hugo.spf13.com/post/reentrantlock%E7%AC%94%E8%AE%B0/">ReentrantLock笔记</a></li>
            
            <li><a href="http://hugo.spf13.com/post/nio%E7%AC%94%E8%AE%B0/">Nio笔记</a></li>
            
            <li><a href="http://hugo.spf13.com/post/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">Git常用命令</a></li>
            
            <li><a href="http://hugo.spf13.com/post/cron%E8%A1%A8%E8%BE%BE%E5%BC%8F/">Cron表达式</a></li>
            
            <li><a href="http://hugo.spf13.com/post/countdownlatch/">CountDownLatch</a></li>
            
            <li><a href="http://hugo.spf13.com/about/">About Hugo</a></li>
            
        </ul>
    </div>
    

    
    <div id="tags" class="open">
        <h3 data-open="tags">Tags</h3>
        <ul class="tags">
            
            <li><a href="http://hugo.spf13.com/tags/cron">cron</a></li>
            
            <li><a href="http://hugo.spf13.com/tags/git">git</a></li>
            
            <li><a href="http://hugo.spf13.com/tags/java">java</a></li>
            
            <li><a href="http://hugo.spf13.com/tags/nio">nio</a></li>
            
            <li><a href="http://hugo.spf13.com/tags/tcpdump">tcpdump</a></li>
            
            <li><a href="http://hugo.spf13.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B">多线程</a></li>
            
        </ul>
    </div>
    

    
    <div id="categories" class="open">
        <h3 data-open="categories">Categories</h3>
        <ul class="categories">
            
            <li><a href="http://hugo.spf13.com/categories/git">git</a></li>
            
            <li><a href="http://hugo.spf13.com/categories/java">java</a></li>
            
            <li><a href="http://hugo.spf13.com/categories/linux">linux</a></li>
            
            <li><a href="http://hugo.spf13.com/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B">多线程</a></li>
            
        </ul>
    </div>
    
</nav>

</div>
<div class="col-md-9 content">

<h1>ReentrantLock笔记</h1>
<h4>Published 09-19-2019 17:52:58</h4>

<a href="https://twitter.com/share" class="twitter-share-button" data-via="kendo5731"></a>
<script>!function (d, s, id) {
    var js, fjs = d.getElementsByTagName(s)[0], p = /^http:/.test(d.location) ? 'http' : 'https';
    if (!d.getElementById(id)) {
        js = d.createElement(s);
        js.id = id;
        js.src = p + '://platform.twitter.com/widgets.js';
        fjs.parentNode.insertBefore(js, fjs);
    }
}(document, 'script', 'twitter-wjs');</script>

<div class="fb-share-button" data-href="http://hugo.spf13.com/post/reentrantlock%E7%AC%94%E8%AE%B0/" data-layout="button"></div>
<div id="fb-root"></div>
<script>(function(d, s, id) {
    var js, fjs = d.getElementsByTagName(s)[0];
    if (d.getElementById(id)) return;
    js = d.createElement(s); js.id = id;
    js.src = "//connect.facebook.net/en-US/sdk.js#xfbml=1&version=v2.5";
    fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>

<article>
    

<h2 id="reentrantlock-note">reentrantlock note</h2>

<hr />

<p>reentrantlock实例化方法有公平锁和非公平锁，默认使用非公平锁。</p>

<pre><code class="language-java">	public ReentrantLock() {
        sync = new NonfairSync();
    }

    public ReentrantLock(boolean fair) {
        sync = fair ? new FairSync() : new NonfairSync();
    }
</code></pre>

<p>此处可以看到非公平锁是<code>NonfairSync</code>和公平锁是<code>FairSync</code>两个类，这两个类都继承于 <code>AbstractQueuedSynchronizer</code>，<code>AbstractQueuedSynchronizer</code>也就是
大名鼎鼎的<strong>AQS</strong>,参考连接 <a href="https://www.jianshu.com/p/da9d051dcc3d">https://www.jianshu.com/p/da9d051dcc3d</a></p>

<pre><code class="language-java">    abstract static class Sync extends AbstractQueuedSynchronizer {}
    static final class NonfairSync extends Sync {}       
    static final class FairSync extends Sync {}
</code></pre>

<p>NonFairSync和FairSync有两处不同，第一处是在调用lock方法时，第二处是在各自的acquire。</p>

<p>当NonFairSync调用lock方法时：</p>

<pre><code class="language-java">        final void lock() {
            if (compareAndSetState(0, 1))
                setExclusiveOwnerThread(Thread.currentThread());
            else
                acquire(1);
        }
</code></pre>

<p>当FairSync调用lock方法时：</p>

<pre><code class="language-java">        final void lock() {
            acquire(1);
        }
</code></pre>

<p>对比可见，NonFairSync会先进行一次<code>compareAndSetState</code>,也就是CAS（原子性操作）。<strong>这是两者的第一处区别。</strong>
<code>compareAndSetState</code>这就是常说的插队，去获取锁。如果成功，执行<code>setExclusiveOwnerThread</code>设置当前线程为锁的占有者；</p>

<p>如果没有获取到锁，执行acquire，</p>

<pre><code class="language-java">    public final void acquire(int arg) {
        if (!tryAcquire(arg) &amp;&amp;
            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
            selfInterrupt();
    }
</code></pre>

<h3 id="tryacquire">tryAcquire</h3>

<p>此处需要注意NonFairSync和FairSync的tryAcquire方法有所区别。</p>

<p>NonFairSync的tryAcquire：</p>

<pre><code class="language-java">        protected final boolean tryAcquire(int acquires) {
            return nonfairTryAcquire(acquires);
        }

        final boolean nonfairTryAcquire(int acquires) {
            final Thread current = Thread.currentThread();
            int c = getState();
            if (c == 0) {
                if (compareAndSetState(0, acquires)) {
                    setExclusiveOwnerThread(current);
                    return true;
                }
            }
            else if (current == getExclusiveOwnerThread()) {
                int nextc = c + acquires;
                if (nextc &lt; 0) // overflow
                    throw new Error(&quot;Maximum lock count exceeded&quot;);
                setState(nextc);
                return true;
            }
            return false;
        }

</code></pre>

<p>FairSync的tryAcquire：</p>

<pre><code class="language-java">        protected final boolean tryAcquire(int acquires) {
            final Thread current = Thread.currentThread();
            int c = getState();
            if (c == 0) {
                if (!hasQueuedPredecessors() &amp;&amp;
                    compareAndSetState(0, acquires)) {
                    setExclusiveOwnerThread(current);
                    return true;
                }
            }
            else if (current == getExclusiveOwnerThread()) {
                int nextc = c + acquires;
                if (nextc &lt; 0)
                    throw new Error(&quot;Maximum lock count exceeded&quot;);
                setState(nextc);
                return true;
            }
            return false;
        }

</code></pre>

<p><strong>两者第二处区别在于判断<code>c == 0</code>之后的操作</strong>，NonFairSync直接获取锁，FairSync需要判断队列中是否有等待线程，如果有获取线程失败，需要排队；如果没有，CAS，设置当前线程为锁的持有者。</p>

<h3 id="acquirequeued">acquireQueued</h3>

<p>如果tryAcquire失败（获取锁失败），则调用acquireQueued，添加至队列排队。</p>

<pre><code class="language-java">    public final void acquire(int arg) {
        if (!tryAcquire(arg) &amp;&amp;
            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
            selfInterrupt();
    }
</code></pre>

<p>看一下addWaiter：</p>

<pre><code class="language-java">    /** Marker to indicate a node is waiting in shared mode */
    static final Node SHARED = new Node(); // 共享锁模式
    /** Marker to indicate a node is waiting in exclusive mode */
    static final Node EXCLUSIVE = null;// 独占锁模式
    ...

    Node(Thread thread, Node mode) {     // Used by addWaiter
        this.nextWaiter = mode;
        this.thread = thread;
    }

    ...
    private Node enq(final Node node) {
        for (;;) {
            Node t = tail;
            if (t == null) { // Must initialize
                if (compareAndSetHead(new Node()))
                    tail = head;
            } else {
                node.prev = t;
                if (compareAndSetTail(t, node)) {
                    t.next = node;
                    return t;
                }
            }
        }
    }

    ...

    private Node addWaiter(Node mode) {
        Node node = new Node(Thread.currentThread(), mode);
        // Try the fast path of enq; backup to full enq on failure
        Node pred = tail;
        if (pred != null) {
            node.prev = pred;
            if (compareAndSetTail(pred, node)) {
                pred.next = node;
                return node;
            }
        }
        enq(node);
        return node;
    }
</code></pre>

<p>addWaiter方法首先初始化了一个EXCLUSIVE模式的Node节点。双向队列。Node节点分两种模式，一种SHARED共享锁模式，一种EXCLUSIVE独占锁模式，
ReentrantLock使用的是EXCLUSIVE独占锁模式，所用用EXCLUSIVE来初始化。
初始化Node节点之后就是将节点加入到队列之中，通过compareAndSetTail设置尾节点，如果CAS设置尾节点不成功，需要enq自旋进行CAS操作来设置尾节点，这样即保证了线程安全，又保证了设置成功，这是一种乐观的锁模式，当然你可以通过synchronized关键字锁住这个方法，但这样效率就会下降，是一种悲观锁模式。</p>

<p>将当前线程加入队列之后，需要使用acquireQueue挂起当前线程：</p>

<pre><code class="language-java">    final boolean acquireQueued(final Node node, int arg) {
        boolean failed = true;
        try {
            boolean interrupted = false;
            for (;;) {
                final Node p = node.predecessor();// 获取当前节点的前置节点
                if (p == head &amp;&amp; tryAcquire(arg)) {// 如果前置节点是头节点，则当前节点是第一个挂起的节点，此时需要尝试获取锁，如果获得成功，执行以下步骤
                    setHead(node);
                    p.next = null; // help GC
                    failed = false;
                    return interrupted;
                }
                if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;// 如果前置节点不是头节点，或者获取锁失败，查看是否需要挂起当前线程
                    parkAndCheckInterrupt())// 挂起当前线程，当前线程阻塞
                    interrupted = true;
            }
        } finally {
            if (failed)
                cancelAcquire(node);
        }
    }
</code></pre>

<p>下面分析一下shouldParkAfterFailedAcquire：</p>

<pre><code class="language-java">    private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
        int ws = pred.waitStatus;
        if (ws == Node.SIGNAL)// 前置节点可以挂起
            /*
             * This node has already set status asking a release
             * to signal it, so it can safely park.
             */
            return true;
        if (ws &gt; 0) {// 前置节点被取消，跳过前置节点，将前置节点的上一个节点作为当前节点的前置节点，如队列是1-2-3,3是当前节点
            // 2是前置节点，2的waitStatus是CANCELLED，跳过后，现在队列是1-3
            /*
             * Predecessor was cancelled. Skip over predecessors and
             * indicate retry.
             */
            do {
                node.prev = pred = pred.prev;
            } while (pred.waitStatus &gt; 0);
            pred.next = node;
        } else {// 如果线程不可挂起，也不是取消，尝试设置为SIGNAL
            /*
             * waitStatus must be 0 or PROPAGATE.  Indicate that we
             * need a signal, but don't park yet.  Caller will need to
             * retry to make sure it cannot acquire before parking.
             */
            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
        }
        return false;
    }
</code></pre>

<p>此时，我们需要看一下Node中的几种状态（具体的解释可以参考源码，其中英文介绍很详细）：</p>

<pre><code class="language-java">        /** waitStatus value to indicate thread has cancelled */
        static final int CANCELLED =  1;
        /** waitStatus value to indicate successor's thread needs unparking */
        static final int SIGNAL    = -1;
        /** waitStatus value to indicate thread is waiting on condition */
        static final int CONDITION = -2;
        /**
         * waitStatus value to indicate the next acquireShared should
         * unconditionally propagate
         */
        static final int PROPAGATE = -3;
</code></pre>

<h2 id="unlock方法">unlock方法</h2>

<p>unlock：</p>

<pre><code class="language-java">
    public void unlock() {
        sync.release(1);
    }

    ...

    public final boolean release(int arg) {
        if (tryRelease(arg)) {
            Node h = head;
            if (h != null &amp;&amp; h.waitStatus != 0)
                unparkSuccessor(h);
            return true;
        }
        return false;
    }

    protected final boolean tryRelease(int releases) {
        int c = getState() - releases;
        if (Thread.currentThread() != getExclusiveOwnerThread())//释放锁必须要是获取锁的线程，否则退出，保证了这个方法只能单线程访问
            throw new IllegalMonitorStateException();
        boolean free = false;
        if (c == 0) {//独占锁为0后代表锁释放，否则为重入锁，不释放
            free = true;
            setExclusiveOwnerThread(null);
        }
        setState(c);
        return free;
    }
</code></pre>

<p>参考链接：<a href="https://juejin.im/post/5b7235e951882560ed075893">https://juejin.im/post/5b7235e951882560ed075893</a></p>

</article>



</div>
</div>
<script src="http://hugo.spf13.com//js/theme.min.js" type="text/javascript"></script>


</body>
</html>

